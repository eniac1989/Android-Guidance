---
layout: post
color: purple
cover: "http://s3-ap-southeast-1.amazonaws.com/monster-machine/images/horssghonr-1436272011-Midas.jpg"
title:  "Dalvik virtual Machine!"
date:   2019-06-17 13:50:39
categories: android basic knowledge
---
<h1 dir="rtl" align="right">
 2. معماری ماشین مجازی Dalvik
</h1>
<div dir="rtl" align="right">
جاوا همیشه با این عنوان که "یکجا بنویس ، و همه جا اجرا کن" شناخته شده و چنین قابلیتی با پلت فرم جاوا که بنیان و اساس آن Java Virtual Machin یا JVM هست امکان پذیر شده است.
اگرچه این هدف برای پلت فرم جاوا در محیط دسکتاپ (JSE)و سرور (J2EE) اجرایی شده اما اکوسیستم موبایل جاوا (JME)  با پیکربندی ها ، پروفایل ها و بسته های مختلف و متنوعی قطعه قطعه شده و یکپارچه نیست که این اتفاق در نهایت منجر به تغییرات مهمی در برنامه میشود تا برای دستگاه های مختلف قابل استفاده  و پشتیبانی باشد.
زمانی که گوگل جاوا را به عنوان زبانی برای توسعه برنامه های اندرویدی انتخاب کرد ، JME   و JVM را رها کرده و آن را با ماشین مجازی Dalvik جایگزین کرد.گوگل حتی برای یکسری از کتابخانه های استاندارد جاوا پیاده سازی هایی محدود و جایگزین نیز ارائه کرد که هردو این ها (هم کتابخانه و هم ماشین مجازی) جاوا غیر استاندارد بوده و در واقع انشعابی از جاوا می باشند.
در این بخش به دلایل فنی که منجر به ایجاد ماشین مجازی غیر استاندارد Dalvik و استفاده آن توسط گوگل شد و همینطور معماری Dalvik خواهیم پرداخت.

</div>
<h2>
<div dir="rtl" align="right">
2.1.	محدودیت های طراحی تحمیل شده توسط پلت فرم های هدف
</div>
</h2>

<div dir="rtl" align="right">
پلت فرم اندروید برای دستگاههای با قدرت پردازش ، حافظه و فضای ذخیره سازی محدود طراحی شده است.حداقل نیازمندی برای یک دستگاه اندروید به شرح ذیل است :
</div>
<table>
  <tr>
    <th>ویژگی</th>
    <th>حداقل نیازمندی</th>
    
  </tr>
  <tr>
    <td>تراشه</td>
    <td>ARM-Based</td>
    
  </tr>
  <tr>
    <td>حافظه</td>
    <td>128 MB RAM,256 MB Flash External</td>    
  </tr>
   <tr>
    <td>فضای ذخیره سازی</td>
    <td>Mini or Micro SD</td>    
  </tr>
   <tr>
    <td>صفحه نمایش اولیه</td>
    <td>QVGA TFT LCD or Larger , 16 bit  color  or better</td>    
  </tr>
   <tr>
    <td>کلید های هدایت </td>
    <td>5-way navigation with 5 application keys ,power, camera and volume controls</td>    
  </tr>
   <tr>
    <td>دوربین </td>
    <td>2MP CMOS</td>    
  </tr>
   <tr>
    <td>USB</td>
    <td>Standard Mini-B USB interface</td>    
  </tr>
    <tr>
    <td>Blutooth</td>
    <td>1.2 یا 2.0</td>    
  </tr>
</table>

<br/>
<div dir="rtl" align="right">
اگرچه گوشی های هوشمند با امکاناتی فراتر از آنچه بالا گفته شد در حال حاضر وجود دارند و به سرعت در حال رشد هستند اما آنچه در جدول بالا میبینیم گویای این است که پلت فرم در واقع باید تعداد وسیعی از دستگاههای با محدودیت منابع را پوشش داده و مورد هدف خود قرار دهد.
با توجه به چنین بازه وسیعی از محیط های هدف ، لازم است تا پلت فرمی که برنامه های کاربردی قرار است برروی آن اجرا شوند از سخت افزار و سیستم عامل به صورت انتزاعی جدا شود.
چنین نیازمندی را با این شرح میتوان بیان و خلاصه نمود که Andoid runtime باید موارد زیر را پشتیبانی نماید:
<br/>
-	Limited processor speed
<br/>
-	Limited RAM
<br/>
-	No swap Space
<br/>
-	Battery powered
<br/>
-	Diverse set of devices
<br/>
-	Sandboxed application runtime

</div>
<div dir="rtl" align="right">
<h2>
<div dir="rtl" align="right">
2.2.	مروری کلی بر طراحی
</div>
</h2>
با توجه به آنچه گفته شد در خصوص اینکه اندروید (Android Application runtime) باید مجموعه ای متنوع از دستگاه ها را پشتیبانی کرده و این برنامه ها می بایست به لحاظ امنیت ، کارایی و قابلیت اطمینان sandbox باشند ، بنظر میرسد که ماشین مجازی انتخاب واضحی برای این منظور باشد.
اما این را هم نباید فراموش کنیم که یک virtual machine runtime لزوما به ایجاد تعادلی در این نیازمندی ها به شما کمک نمی کند با توجه به اینکه این دستگاهها قدرت پردازشی  و RAM محدود دارند.
لذا برای پیاده سازی  محیطی runtime برای برنامه های کاربردی با توجه به این محدودیت ها گوگل روش زیر را درنظر گرفت :
هر برنامه کاربردی برروی پراسس و با نمونه ی خود از ماشین مجازی Dalvik اجرا می شود.Dalvik طوری نوشته شده است که هر دستگاه بتونه چندین VM را به صورتی کارآمد اجرا کند.ماشین مجازی Dalvik فایل ها را با فرمت Dalvik Executable(.dex) که برای فضای حافظه کوچک بهینه سازی شده اند اجرا می کند.ماشین مجازی مبتنی بر رجیستر هست و کلاس های جاوا که توسط کامپایلر جاوا کامپایل شده اند و توسط ابزار “dx” به فرمت .dex تبدیل شده اند را اجرا می کند.
این ماشین مجازی برای یک سری از وظیفه مندی های زیر ساختی مثل threading و مدیریت سطوح پایین حافظه به کرنل لینوکس اتکا می کند.
</div>

<div dir="rtl" align="right">
<h2>
<div dir="rtl" align="right">
2.3.	فرمت فایل DEX
</div>
</h2>
در محیط استاندارد جاوا ، سورس کد جاوا به بایت کدهای جاوا کامپایل می شوند که در داخل فایل های .class ذخیره سازی می شوند.این فایل های .class در زمان اجرا توسط JVM خوانده می شوند.هر کلاسی در کد جاوا شما تبدیل به یک فایل .class می شود.به این معنی که اگر شما یک فایل منبع .java داشته باشید که شامل یک کلاس public  ، یک کلاس استاتیک داخلی و 3 کلاس anonymous داشته باشد ، کامپایلر 5 فایل .class ایجا خواهد کرد.
در پلت فرم اندروید ، سورس کد جاوا همچنان به فایل .class کامپایل می شود. اما پس از آن که فایل های .class تولید می شوند ، ابزار “dx” فایل های .class را به .dex (یا در واقع فایل های اجرایی dalvik) تبدیل می کند .در جایی که فایل .class  شامل تنها یک کلاس هست ، فایل .dex شامل چندین کلاس است . فایل .dex برای کاربرد حافظه و بهینه سازی شده و طراحی آن از به اشتراک گذاری داده نشئت گرفته است.
آنچه در تصویر زیر می بینید پروسه کامپایل شدن کد ها در دو ماشین مجازی JVM و Dalvik و تبدیل آنها  به فرمت های اجرایی دو ماشین مجازی مذکور است.
<div align="center">
 <p><img src="../assets/images/Dalvik.png" alt="screenshot" /></p>
</div>
</div>
<div dir="rtl" align="right">
<h2>
<div dir="rtl" align="right">
2.4.	ZYGOT
</div>
</h2>

چون هر برنامه برروی VM خود اجرا می شود ، نمونه های VM باید قادر باشند تا بلافاصله پس از اجرای برنامه ی جدید آغاز شده و حافظه مصرفی آن ها نیز حداقل باشد.اندروید از مفهومی به نام Zygot استفاده می کند تا بدین وسیله هم زمان راه اندازی یک VM کم کند و هم اینکه امکان به اشتراک گذاری کد در بین نمونه های VM را فراهم نماید.طراحی Zygot فرض می کند که تعداد زیادی کلاس های اصلی کتابخانه ای وجود دارد و مطابق آن ها ساختارهای heap که در سراسر این برنامه های کاربردی استفاده می شوند.همچنین این فرض را می کند که این ساختار های heap به صورت عمومی read-only هستند.
Zygot در واقع یک پراسس VM است که در زمان بوت سیستم راه اندازی می شود.وقتی پراسس Zygot آغاز می شود ، یک Dalvik VM را راه اندازی می کند که کلاس های کتابخانه اصلی را پیشتر بارگذاری و مقداردهی می کند.
به صورت کلی این کلاس ها read-only هستند و بنابراین کاندیداهای خوبی برای پیش بارگذاری و به اشتراک گذاری در بین پردازش ها می باشند.وقتی zygot راه اندازی می شود منتظر  درخواست های سوکت که از طرف پراسس runtime می آید می نشیند که بسته به نمونه zygot VM باید نمونه های جدید VM را ایجاد و منشعب کند.شروع و راه اندازی یک VM زمانبر است و می تواند مانعی برای اجرای انحصاری هر برنامه برروی VM خود باشد.با منشعب کردن پردازش های VM جدید از Zygot ، زمان راه اندازی کاهش می یابد.
کلاسهای کتابخانه اصلی که بین نمونه های VM به اشتراک گذارده می شوند Read-only هستند ولی توسط برنامه ها نوشته نمی شوند.زمانی این کلاس ها نوشته می شوند ، حافظه از پراسس مشترک  Zygot برروی پراسس منشعب شده VM برنامه کپی می شود.این رفتار copy-on-write امکان حداکثر به اشتراک گذاری حافظه را در حالتی که مانع از تداخل برنامه ها برروی یکدیگر می شود می دهد و باعث تامین امنیت برنامه ها می گردد.
این در صورتی هست که در طراحی سنتی Java VM هر نمونه از VM یک کپی کامل از فایل های کتابخانه اصلی و هر شی heap مرتبط دارد .حافظه در بین نمونه ها مشترک نیست.
</div>
<div dir="rtl" align="right">
<h2>
<div dir="rtl" align="right">
2.5.	معماری مبتنی بر رجیستر
</div>
</h2>

به صورت سنتی طراحان و پیاده سازان ماشین های مجازی معماری مبتنی بر استک را به معماری مبتنی بر رجیستر ترجیح  میداده اند که این اکثرا به دلیل سادگی پیاده سازی VM سادگی نوشتن بک – اند کامپایلر بوده است.
مطالعات نشان داده است که : 
معماری های مبتنی بر رجیستر به دستورات اجرایی VM نسبت به معماری مبتنی بر استک به طور میانگین 47% کمتر نیاز دارند.از طرف دیگر کد رجیستر 25% بزرگتر از حالت معادل آن در استک است .به دلیل آنکه در حالت رجیستر آدرس operand ها می بایست در رجیستر ها ذخیره شود و این در حالیست که در حالت استک به دلیل استفاده از اشاره گر ها این دستورات کوچکترند.
اما این اتفاق منجر به افزایش هزینه خواندن و fetch کردن تعداد دستورات بیشتری از VM می شود که شامل تنها 1.07% بار اضافی بیشتر به ازای هر دستور VM است که قابل چشم پوشی و اغماض می باشد.
در کل کارایی VM مبتنی بر رجیستر به طور میانگین 32.3% زمان کمتر در اجرای دستورات نسبت به VM مبتنی بر استک است.بنابراین با توجه به آنکه با دستگاههای با قدرت پردازشی محدود و فضای حافظه محدود مواجه هستیم انتخاب معماری مبتنی بررجیستر واضح و معقول است .اگرچه کد مبتنی بر رجیستر حدودا 25% بزرگنر از کد مبتنی بر استک است ، 50% در سایز کد با توجه به استخر فضای اشتراکی constant ها در فایل .dex کاهش خواهیم داشت که جبران کننده این مورد می باشد.
</div>
<div dir="rtl" align="right">
<h2>
<div dir="rtl" align="right">
2.6.	امنیت
</div>
</h2>

معماری اندروید این تضمین را می دهد که هیچ برنامه کاربردی مجوز انجام عملیاتی که برروی دیگر برنامه های کاربردی ، سیستم عامل یا کاربر داشته باشد را ندارد.این شامل خواندن یا نوشتن داده های خصوصی کاربر مثل تماس ها یا ایمیل ها ، خواندن و نوشتن برروی فایل های برنامه های کاربردی دیگر ، یا دسترسی به شبکه و ... می باشد.
این ویژگی ها در سطح سیستم عامل و فریم ورک اندروید پیاده سازی شده و در سطح Dalvik VM نمی باشد.اگر برنامه ای احتیاج به مجوزهای بیشتری داشته باشد این درخواست ها را در مانیفست برنامه اعلام می کند.این مجوز ها در زمان نصب برنامه توسط فریم ورک اعتبارسنجی شده و در زمان اجرا توسط سیستم عامل اعمال می گردد.
آنچه در تصویر زیر میبینید پروسه ایجاد یک ماشین مجازی Dalvik است که از ابتدای بوت شدن سیستم عامل اندروید برروی کرنل لینوکس مورد بررسی قرار گرفته است:
<div align="center">
 <p><img src="../assets/images/zygot.png" alt="screenshot" /></p>
</div>
زمانی که سیستم بوت می شود ، بوت لودر ،کرنل را در حافظه لود کرده و پارامترهای سیستم را مقداردهی اولیه می کند.بلافاصله پس از آن :
<br/>
-	کرنل برنامه Init را اجرا کرده که در واقع پراسس والد تمام پراسسهای سیستم است.
<br/>
-	برنامه Init سرویس Zygot را راه اندازی می کند.
<br/>
-	پراسس Zygot یک نمونه از Dalvik را که پراسس Dalvik والد برای کلیه ی نمونه های Dalvik VM برروی سیستم خواهد بود ایجاد می کند.
<br/>
-	پراسس Zygot همچنین با استفاده از سوکت BSD که راه اندازی میکند منتظر درخواست های ورودی می ماند.
<br/>
-	هنگامی که یک درخواست جدید برای یک نمونه از Dalvik VM دریافت می شود، پراسس Zygot از پراسس Dalvik والد انشعابی ایجاد کرده و پراسس فرزند را برای برنامه ای که آن را درخواست کرده ارسال می کند.
</div>

